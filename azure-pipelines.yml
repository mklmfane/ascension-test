# azure-pipelines.yml
trigger: none

variables:
  serviceConnection: 'terraform-access'
  GO_VERSION: '1.24.5'
  TFSEC_VERSION: 'v1.28.14'
  TFLINT_VERSION: 'v0.59.1'
  doDestroy: 'false'
  # used by the import guard; match your TF naming
  RG_NAME_PREFIX: 'ascension-up'
  location: 'westeurope'   # only used if you later create state infra, etc.

stages:
# ========= BUILD ONCE =========
- stage: build
  displayName: 'Build & package apps'
  jobs:
  - job: build_apps
    pool: { name: 'ubuntuvm' }
    steps:
    - checkout: self
      clean: true

    # Minimal packaging (replace with your real build)
    - bash: |
        set -euo pipefail
        mkdir -p "$(Build.SourcesDirectory)/_pkg/frontend" "$(Build.SourcesDirectory)/_pkg/function"
        echo "<html><body>placeholder</body></html>" > "$(Build.SourcesDirectory)/_pkg/frontend/index.html"
        echo "{}" > "$(Build.SourcesDirectory)/_pkg/function/host.json"
      displayName: 'Create placeholder files'

    - task: ArchiveFiles@2
      displayName: 'Zip frontend'
      inputs:
        rootFolderOrFile: '$(Build.SourcesDirectory)/_pkg/frontend'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/frontend/frontend.zip'
        replaceExistingArchive: true

    - task: ArchiveFiles@2
      displayName: 'Zip function'
      inputs:
        rootFolderOrFile: '$(Build.SourcesDirectory)/_pkg/function'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/function/function.zip'
        replaceExistingArchive: true

    - publish: $(Build.ArtifactStagingDirectory)/frontend
      artifact: frontend
    - publish: $(Build.ArtifactStagingDirectory)/function
      artifact: function

# ========= OPTIONAL PREVIEW (single) =========
- stage: tf_preview
  displayName: 'TF plan (preview)'
  dependsOn: build
  jobs:
  - job: plan_preview
    pool: { name: 'ubuntuvm' }
    steps:
    - checkout: self
      clean: true
    - task: AzureCLI@2
      displayName: 'Login + lint + preview (dev)'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          az account show

          BIN_DIR="$(Agent.TempDirectory)/bin"; mkdir -p "$BIN_DIR"; export PATH="$BIN_DIR:$PATH"
          if ! command -v go >/dev/null; then
            GO_TGZ="go$(GO_VERSION).linux-amd64.tar.gz"
            curl -sSL "https://go.dev/dl/${GO_TGZ}" -o "${GO_TGZ}"
            tar -C "$(Agent.TempDirectory)" -xzf "${GO_TGZ}"
            export GOROOT="$(Agent.TempDirectory)/go"
            export GOPATH="$(Agent.TempDirectory)/gopath"
            export GOBIN="$BIN_DIR"
            export PATH="$GOROOT/bin:$GOBIN:$GOPATH/bin:$PATH"
          else
            export GOBIN="$BIN_DIR"; export GOPATH="$(Agent.TempDirectory)/gopath"; export PATH="$GOBIN:$GOPATH/bin:$PATH"
          fi
          if ! command -v tfsec >/dev/null; then go install "github.com/aquasecurity/tfsec/cmd/tfsec@${TFSEC_VERSION}"; fi
          if ! command -v tflint >/dev/null; then
            TMP="$(mktemp -d)"; curl -sSL "https://github.com/terraform-linters/tflint/releases/download/$(TFLINT_VERSION)/tflint_linux_amd64.zip" -o "${TMP}/tflint.zip"
            unzip -q "${TMP}/tflint.zip" -d "${TMP}"; install -m 0755 "${TMP}/tflint" "${BIN_DIR}/tflint"
          fi

          tflint --init
          tflint --recursive
          tfsec "$(Build.SourcesDirectory)/terraform" || true

          terraform -chdir="$(Build.SourcesDirectory)/terraform" init -input=false
          terraform -chdir="$(Build.SourcesDirectory)/terraform" validate
          terraform -chdir="$(Build.SourcesDirectory)/terraform" workspace select -or-create "dev"

          SC_CLIENT_ID="331a5bcb-b95d-4529-a528-c858e28d9a89"
          PIPELINE_PRINCIPAL_OBJECT_ID=$(az ad sp show --id "$SC_CLIENT_ID" --query id -o tsv)

          terraform -chdir="$(Build.SourcesDirectory)/terraform" plan -input=false \
            -var="workflow=dev" \
            -var="pipeline_principal_id=$PIPELINE_PRINCIPAL_OBJECT_ID" \
            -out="tfplan.preview.out"
    - publish: $(Build.SourcesDirectory)/terraform/tfplan.preview.out
      artifact: tfplan-preview

# ========= DEV (infra -> apps) =========
- stage: dev_infra
  displayName: 'Dev: deploy infra'
  dependsOn: tf_preview
  jobs:
  - job: dev_infra
    pool: { name: 'ubuntuvm' }
    variables:
      env: 'dev'
    steps:
    - checkout: self
      clean: true

    - task: AzureCLI@2
      displayName: 'Login + tools + plan/apply (dev)'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          az account show
          BIN_DIR="$(Agent.TempDirectory)/bin"; mkdir -p "$BIN_DIR"; export PATH="$BIN_DIR:$PATH"
          if ! command -v go >/dev/null; then
            GO_TGZ="go$(GO_VERSION).linux-amd64.tar.gz"
            curl -sSL "https://go.dev/dl/${GO_TGZ}" -o "${GO_TGZ}"
            tar -C "$(Agent.TempDirectory)" -xzf "${GO_TGZ}"
            export GOROOT="$(Agent.TempDirectory)/go"; export GOPATH="$(Agent.TempDirectory)/gopath"; export GOBIN="$BIN_DIR"
            export PATH="$GOROOT/bin:$GOBIN:$GOPATH/bin:$PATH"
          else
            export GOBIN="$BIN_DIR"; export GOPATH="$(Agent.TempDirectory)/gopath"; export PATH="$GOBIN:$GOPATH/bin:$PATH"
          fi
          if ! command -v tfsec >/dev/null; then go install "github.com/aquasecurity/tfsec/cmd/tfsec@${TFSEC_VERSION}"; fi
          if ! command -v tflint >/dev/null; then
            TMP="$(mktemp -d)"; curl -sSL "https://github.com/terraform-linters/tflint/releases/download/$(TFLINT_VERSION)/tflint_linux_amd64.zip" -o "${TMP}/tflint.zip"
            unzip -q "${TMP}/tflint.zip" -d "${TMP}"; install -m 0755 "${TMP}/tflint" "${BIN_DIR}/tflint"
          fi

          tflint --init
          tflint --recursive
          tfsec "$(Build.SourcesDirectory)/terraform" || true

          terraform -chdir="$(Build.SourcesDirectory)/terraform" init -input=false
          terraform -chdir="$(Build.SourcesDirectory)/terraform" workspace select -or-create "$(env)"

          # ------- import-if-exists guard for RG -------
          SUB_ID=$(az account show --query id -o tsv)
          RG_NAME="$(RG_NAME_PREFIX)-$(env)-rg"
          if az group exists -n "$RG_NAME"; then
            echo "RG $RG_NAME exists. Importing into state if missingâ€¦"
            if ! terraform -chdir="$(Build.SourcesDirectory)/terraform" state show azurerm_resource_group.ascension_test_rg >/dev/null 2>&1; then
              terraform -chdir="$(Build.SourcesDirectory)/terraform" import azurerm_resource_group.ascension_test_rg "/subscriptions/$SUB_ID/resourceGroups/$RG_NAME" || true
            fi
          fi
          # --------------------------------------------

          SC_CLIENT_ID="331a5bcb-b95d-4529-a528-c858e28d9a89"
          PIPELINE_PRINCIPAL_OBJECT_ID=$(az ad sp show --id "$SC_CLIENT_ID" --query id -o tsv)

          terraform -chdir="$(Build.SourcesDirectory)/terraform" plan -no-color -input=false \
            -var="workflow=$(env)" \
            -var="pipeline_principal_id=$PIPELINE_PRINCIPAL_OBJECT_ID" \
            -out="tfplan.$(env).out"

          # Apply only on main
          if [ "$(Build.SourceBranch)" = "refs/heads/main" ]; then
            terraform -chdir="$(Build.SourcesDirectory)/terraform" apply -auto-approve -no-color "tfplan.$(env).out"
            terraform -chdir="$(Build.SourcesDirectory)/terraform" output -json > "$(Build.SourcesDirectory)/terraform/tf-outputs.$(env).json"
          else
            echo "Not main branch, skipping apply."
          fi
    - publish: $(Build.SourcesDirectory)/terraform/tf-outputs.$(env).json
      artifact: tf-outputs-$(env)
      condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))

- stage: dev_apps
  displayName: 'Dev: deploy apps'
  dependsOn:
    - build
    - dev_infra
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: dev_apps
    pool: { name: 'ubuntuvm' }
    variables: { env: 'dev' }
    steps:
    - download: current
      artifact: frontend
    - download: current
      artifact: function
    - download: current
      artifact: tf-outputs-$(env)

    - task: AzureCLI@2
      displayName: 'Deploy frontend + function (dev)'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          FRONTEND_ZIP="$(Pipeline.Workspace)/frontend/frontend.zip"
          FUNCTION_ZIP="$(Pipeline.Workspace)/function/function.zip"
          TF_OUT="$(Pipeline.Workspace)/tf-outputs-$(env)/tf-outputs.$(env).json"

          RG=$(python -c "import json;print(json.load(open('$TF_OUT'))['resource_group_name']['value'])")
          WEB=$(python -c "import json;print(json.load(open('$TF_OUT'))['react_web_name']['value'])")
          FN=$(python -c "import json;print(json.load(open('$TF_OUT'))['function_name']['value'])")

          az webapp deployment source config-zip -g "$RG" -n "$WEB" --src "$FRONTEND_ZIP"
          az functionapp config appsettings set -g "$RG" -n "$FN" --settings SCM_DO_BUILD_DURING_DEPLOYMENT=true
          az functionapp deployment source config-zip -g "$RG" -n "$FN" --src "$FUNCTION_ZIP"
          curl -fsS "https://${FN}.azurewebsites.net/api/products" || true

# ========= TEST (infra -> apps), waits for DEV apps =========
- stage: test_infra
  displayName: 'Test: deploy infra'
  dependsOn: dev_apps
  jobs:
  - job: test_infra
    pool: { name: 'ubuntuvm' }
    variables: { env: 'test' }
    steps:
    - checkout: self
      clean: true
    - task: AzureCLI@2
      displayName: 'Login + tools + plan/apply (test)'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          az account show
          BIN_DIR="$(Agent.TempDirectory)/bin"; mkdir -p "$BIN_DIR"; export PATH="$BIN_DIR:$PATH"
          if ! command -v go >/dev/null; then
            GO_TGZ="go$(GO_VERSION).linux-amd64.tar.gz"
            curl -sSL "https://go.dev/dl/${GO_TGZ}" -o "${GO_TGZ}"
            tar -C "$(Agent.TempDirectory)" -xzf "${GO_TGZ}"
            export GOROOT="$(Agent.TempDirectory)/go"; export GOPATH="$(Agent.TempDirectory)/gopath"; export GOBIN="$BIN_DIR"
            export PATH="$GOROOT/bin:$GOBIN:$GOPATH/bin:$PATH"
          else
            export GOBIN="$BIN_DIR"; export GOPATH="$(Agent.TempDirectory)/gopath"; export PATH="$GOBIN:$GOPATH/bin:$PATH"
          fi
          if ! command -v tfsec >/dev/null; then go install "github.com/aquasecurity/tfsec/cmd/tfsec@${TFSEC_VERSION}"; fi
          if ! command -v tflint >/dev/null; then
            TMP="$(mktemp -d)"; curl -sSL "https://github.com/terraform-linters/tflint/releases/download/$(TFLINT_VERSION)/tflint_linux_amd64.zip" -o "${TMP}/tflint.zip"
            unzip -q "${TMP}/tflint.zip" -d "${TMP}"; install -m 0755 "${TMP}/tflint" "${BIN_DIR}/tflint"
          fi

          tflint --init
          tflint --recursive
          tfsec "$(Build.SourcesDirectory)/terraform" || true

          terraform -chdir="$(Build.SourcesDirectory)/terraform" init -input=false
          terraform -chdir="$(Build.SourcesDirectory)/terraform" workspace select -or-create "$(env)"

          # import-if-exists guard
          SUB_ID=$(az account show --query id -o tsv)
          RG_NAME="$(RG_NAME_PREFIX)-$(env)-rg"
          if az group exists -n "$RG_NAME"; then
            if ! terraform -chdir="$(Build.SourcesDirectory)/terraform" state show azurerm_resource_group.ascension_test_rg >/dev/null 2>&1; then
              terraform -chdir="$(Build.SourcesDirectory)/terraform" import azurerm_resource_group.ascension_test_rg "/subscriptions/$SUB_ID/resourceGroups/$RG_NAME" || true
            fi
          fi

          SC_CLIENT_ID="331a5bcb-b95d-4529-a528-c858e28d9a89"
          PIPELINE_PRINCIPAL_OBJECT_ID=$(az ad sp show --id "$SC_CLIENT_ID" --query id -o tsv)

          terraform -chdir="$(Build.SourcesDirectory)/terraform" plan -no-color -input=false \
            -var="workflow=$(env)" \
            -var="pipeline_principal_id=$PIPELINE_PRINCIPAL_OBJECT_ID" \
            -out="tfplan.$(env).out"

          if [ "$(Build.SourceBranch)" = "refs/heads/main" ]; then
            terraform -chdir="$(Build.SourcesDirectory)/terraform" apply -auto-approve -no-color "tfplan.$(env).out"
            terraform -chdir="$(Build.SourcesDirectory)/terraform" output -json > "$(Build.SourcesDirectory)/terraform/tf-outputs.$(env).json"
          else
            echo "Not main branch, skipping apply."
          fi

    - publish: $(Build.SourcesDirectory)/terraform/tf-outputs.$(env).json
      artifact: tf-outputs-$(env)
      condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))

- stage: test_apps
  displayName: 'Test: deploy apps'
  dependsOn:
    - build
    - test_infra
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: test_apps
    pool: { name: 'ubuntuvm' }
    variables: { env: 'test' }
    steps:
    - download: current
      artifact: frontend
    - download: current
      artifact: function
    - download: current
      artifact: tf-outputs-$(env)
    - task: AzureCLI@2
      displayName: 'Deploy frontend + function (test)'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          FRONTEND_ZIP="$(Pipeline.Workspace)/frontend/frontend.zip"
          FUNCTION_ZIP="$(Pipeline.Workspace)/function/function.zip"
          TF_OUT="$(Pipeline.Workspace)/tf-outputs-$(env)/tf-outputs.$(env).json"
          RG=$(python -c "import json;print(json.load(open('$TF_OUT'))['resource_group_name']['value'])")
          WEB=$(python -c "import json;print(json.load(open('$TF_OUT'))['react_web_name']['value'])")
          FN=$(python -c "import json;print(json.load(open('$TF_OUT'))['function_name']['value'])")
          az webapp deployment source config-zip -g "$RG" -n "$WEB" --src "$FRONTEND_ZIP"
          az functionapp config appsettings set -g "$RG" -n "$FN" --settings SCM_DO_BUILD_DURING_DEPLOYMENT=true
          az functionapp deployment source config-zip -g "$RG" -n "$FN" --src "$FUNCTION_ZIP"
          curl -fsS "https://${FN}.azurewebsites.net/api/products" || true

# ========= PROD (infra -> apps), waits for TEST apps =========
- stage: prod_infra
  displayName: 'Prod: deploy infra'
  dependsOn: test_apps
  jobs:
  - job: prod_infra
    pool: { name: 'ubuntuvm' }
    variables: { env: 'prod' }
    steps:
    - checkout: self
      clean: true
    - task: AzureCLI@2
      displayName: 'Login + tools + plan/apply (prod)'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          az account show
          BIN_DIR="$(Agent.TempDirectory)/bin"; mkdir -p "$BIN_DIR"; export PATH="$BIN_DIR:$PATH"
          if ! command -v go >/dev/null; then
            GO_TGZ="go$(GO_VERSION).linux-amd64.tar.gz"
            curl -sSL "https://go.dev/dl/${GO_TGZ}" -o "${GO_TGZ}"
            tar -C "$(Agent.TempDirectory)" -xzf "${GO_TGZ}"
            export GOROOT="$(Agent.TempDirectory)/go"; export GOPATH="$(Agent.TempDirectory)/gopath"; export GOBIN="$BIN_DIR"
            export PATH="$GOROOT/bin:$GOBIN:$GOPATH/bin:$PATH"
          else
            export GOBIN="$BIN_DIR"; export GOPATH="$(Agent.TempDirectory)/gopath"; export PATH="$GOBIN:$GOPATH/bin:$PATH"
          fi
          if ! command -v tfsec >/dev/null; then go install "github.com/aquasecurity/tfsec/cmd/tfsec@${TFSEC_VERSION}"; fi
          if ! command -v tflint >/dev/null; then
            TMP="$(mktemp -d)"; curl -sSL "https://github.com/terraform-linters/tflint/releases/download/$(TFLINT_VERSION)/tflint_linux_amd64.zip" -o "${TMP}/tflint.zip"
            unzip -q "${TMP}/tflint.zip" -d "${TMP}"; install -m 0755 "${TMP}/tflint" "${BIN_DIR}/tflint"
          fi

          tflint --init
          tflint --recursive
          tfsec "$(Build.SourcesDirectory)/terraform" || true

          terraform -chdir="$(Build.SourcesDirectory)/terraform" init -input=false
          terraform -chdir="$(Build.SourcesDirectory)/terraform" workspace select -or-create "$(env)"

          # import-if-exists guard
          SUB_ID=$(az account show --query id -o tsv)
          RG_NAME="$(RG_NAME_PREFIX)-$(env)-rg"
          if az group exists -n "$RG_NAME"; then
            if ! terraform -chdir="$(Build.SourcesDirectory)/terraform" state show azurerm_resource_group.ascension_test_rg >/dev/null 2>&1; then
              terraform -chdir="$(Build.SourcesDirectory)/terraform" import azurerm_resource_group.ascension_test_rg "/subscriptions/$SUB_ID/resourceGroups/$RG_NAME" || true
            fi
          fi

          SC_CLIENT_ID="331a5bcb-b95d-4529-a528-c858e28d9a89"
          PIPELINE_PRINCIPAL_OBJECT_ID=$(az ad sp show --id "$SC_CLIENT_ID" --query id -o tsv)

          terraform -chdir="$(Build.SourcesDirectory)/terraform" plan -no-color -input=false \
            -var="workflow=$(env)" \
            -var="pipeline_principal_id=$PIPELINE_PRINCIPAL_OBJECT_ID" \
            -out="tfplan.$(env).out"

          if [ "$(Build.SourceBranch)" = "refs/heads/main" ]; then
            terraform -chdir="$(Build.SourcesDirectory)/terraform" apply -auto-approve -no-color "tfplan.$(env).out"
            terraform -chdir="$(Build.SourcesDirectory)/terraform" output -json > "$(Build.SourcesDirectory)/terraform/tf-outputs.$(env).json"
          else
            echo "Not main branch, skipping apply."
          fi
    - publish: $(Build.SourcesDirectory)/terraform/tf-outputs.$(env).json
      artifact: tf-outputs-$(env)
      condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))

- stage: prod_apps
  displayName: 'Prod: deploy apps'
  dependsOn:
    - build
    - prod_infra
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: prod_apps
    pool: { name: 'ubuntuvm' }
    variables: { env: 'prod' }
    steps:
    - download: current
      artifact: frontend
    - download: current
      artifact: function
    - download: current
      artifact: tf-outputs-$(env)
    - task: AzureCLI@2
      displayName: 'Deploy frontend + function (prod)'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          FRONTEND_ZIP="$(Pipeline.Workspace)/frontend/frontend.zip"
          FUNCTION_ZIP="$(Pipeline.Workspace)/function/function.zip"
          TF_OUT="$(Pipeline.Workspace)/tf-outputs-$(env)/tf-outputs.$(env).json"
          RG=$(python -c "import json;print(json.load(open('$TF_OUT'))['resource_group_name']['value'])")
          WEB=$(python -c "import json;print(json.load(open('$TF_OUT'))['react_web_name']['value'])")
          FN=$(python -c "import json;print(json.load(open('$TF_OUT'))['function_name']['value'])")
          az webapp deployment source config-zip -g "$RG" -n "$WEB" --src "$FRONTEND_ZIP"
          az functionapp config appsettings set -g "$RG" -n "$FN" --settings SCM_DO_BUILD_DURING_DEPLOYMENT=true
          az functionapp deployment source config-zip -g "$RG" -n "$FN" --src "$FUNCTION_ZIP"
          curl -fsS "https://${FN}.azurewebsites.net/api/products" || true

# ========= DESTROY (optional, linear after prod apps) =========
- stage: destroy
  displayName: 'Terraform destroy (guarded)'
  dependsOn: prod_apps
  condition: and(succeeded(), eq(variables['doDestroy'], 'true'))
  jobs:
  - job: destroy_all
    pool: { name: 'ubuntuvm' }
    strategy:
      matrix:
        dev:  { env: dev }
        test: { env: test }
        prod: { env: prod }
    steps:
    - checkout: self
      clean: true
    - task: AzureCLI@2
      displayName: "Destroy $(env)"
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          terraform -chdir="$(Build.SourcesDirectory)/terraform" init -input=false
          terraform -chdir="$(Build.SourcesDirectory)/terraform" workspace select -or-create "$(env)"
          terraform -chdir="$(Build.SourcesDirectory)/terraform" destroy -no-color -auto-approve -var="workflow=$(env)"
