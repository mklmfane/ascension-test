trigger: none

variables:
  serviceConnection: 'terraform-access'
  GO_VERSION: '1.24.5'
  TFSEC_VERSION: 'v1.28.14'
  TFLINT_VERSION: 'v0.59.1'
  doDestroy: 'false'
  RG_NAME_PREFIX: 'ascension-up'
  location: 'northeurope'

# =========================
# DEV STAGE (build -> infra -> apps)
# =========================
- stage: dev
  displayName: 'DEV'
  variables: { env: 'dev' }
  jobs:
  # ---- dev_infra ----
  - job: dev_infra
    displayName: 'Provision infra (dev)'
    pool: { name: 'ubuntuvm' }
    steps:
      - checkout: self
        clean: true

      - task: AzureCLI@2
        displayName: 'Login + tools + plan/apply (dev)'
        inputs:
          azureSubscription: '$(serviceConnection)'
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            set -euo pipefail
            az account show

            BIN_DIR="$(Agent.TempDirectory)/bin"; mkdir -p "$BIN_DIR"; export PATH="$BIN_DIR:$PATH"
            # (install go/tfsec/tflint as before) ...

            tflint --init
            tflint --recursive
            tfsec "$(Build.SourcesDirectory)/terraform" || true

            TF_DIR="$(Build.SourcesDirectory)/terraform"
            terraform -chdir="$TF_DIR" init -input=false

            # --- Workspace: create only if missing ---
            ensure_ws() {
              local dir="$1" ws="$2"
              if terraform -chdir="$dir" workspace list | sed 's/*//;s/ //g' | grep -Fxq "$ws"; then
                terraform -chdir="$dir" workspace select "$ws"
              else
                terraform -chdir="$dir" workspace new "$ws"
              fi
            }
            ensure_ws "$TF_DIR" "$(env)"

            SUB_ID=$(az account show --query id -o tsv)
            RG_NAME="$(RG_NAME_PREFIX)-$(env)-rg"
            if az group exists -n "$RG_NAME"; then
              if ! terraform -chdir="$TF_DIR" state show azurerm_resource_group.ascension_test_rg >/dev/null 2>&1; then
                terraform -chdir="$TF_DIR" import azurerm_resource_group.ascension_test_rg "/subscriptions/$SUB_ID/resourceGroups/$RG_NAME" || true
              fi
            fi

            SC_CLIENT_ID="331a5bcb-b95d-4529-a528-c858e28d9a89"
            PIPELINE_PRINCIPAL_OBJECT_ID=$(az ad sp show --id "$SC_CLIENT_ID" --query id -o tsv)

            terraform -chdir="$TF_DIR" plan -no-color -input=false \
              -var="workflow=$(env)" \
              -var="pipeline_principal_id=$PIPELINE_PRINCIPAL_OBJECT_ID" \
              -var="frontend_image_name=frontend-$(env)" \
              -var="frontend_image_tag=${BUILD_BUILDID}" \
              -out="tfplan.$(env).out"

            if [ "$(Build.SourceBranch)" = "refs/heads/main" ]; then
              terraform -chdir="$TF_DIR" apply -auto-approve -no-color "tfplan.$(env).out"
              terraform -chdir="$TF_DIR" output -json > "$TF_DIR/tf-outputs.$(env).json"
            else
              echo "Not main branch, skipping apply."
            fi

      - publish: $(Build.SourcesDirectory)/terraform/tf-outputs.$(env).json
        artifact: tf-outputs-$(env)
        condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
        displayName: 'Publish tf-outputs'

  # ---- build_dev ----
  
  - job: build_dev
    displayName: 'Build frontend for React with App Service & package function (dev)'
    dependsOn: dev_infra
    pool: { name: 'ubuntuvm' }
    steps:
      - checkout: self
        clean: true

      # ACR login server from Terraform outputs is needed to build & push container
      - download: current
        artifact: tf-outputs-$(env)

      - task: AzureCLI@2
        displayName: 'Login + Build & Push Frontend Container to ACR'
        inputs:
          azureSubscription: '$(serviceConnection)'
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            set -euo pipefail

            TF_OUT="$(Pipeline.Workspace)/tf-outputs-$(env)/tf-outputs.$(env).json"
            test -f "$TF_OUT" || { echo "Missing TF outputs at $TF_OUT"; exit 1; }

            ACR_LOGIN_SERVER=$(python3 -c "import json;print(json.load(open('$TF_OUT'))['acr_login_server']['value'])")
            test -n "$ACR_LOGIN_SERVER" || { echo "acr_login_server missing in TF outputs"; exit 1; }
            ACR_NAME="${ACR_LOGIN_SERVER%%.*}"

            echo "Using ACR: $ACR_NAME ($ACR_LOGIN_SERVER)"

            # Ensure Docker is available on your self-hosted agent
            if ! command -v docker >/dev/null 2>&1; then
              echo "Docker not found on agent. Please install & start Docker on 'ubuntuvm'." >&2
              exit 1
            fi

            # Log in to ACR (OIDC-backed service connection is already logged in to Azure)
            az acr login -n "$ACR_NAME"

            # Build from your existing repo structure: frontend/ (expects Dockerfile + nginx.conf there)
            FRONTEND_DIR="$(Build.SourcesDirectory)/frontend"
            test -f "$FRONTEND_DIR/Dockerfile" || { echo "frontend/Dockerfile not found"; exit 1; }
            test -f "$FRONTEND_DIR/nginx.conf" || { echo "frontend/nginx.conf not found"; exit 1; }

            IMG_NAME="frontend-$(env)"
            IMG_TAG="$(Build.BuildId)"
            IMAGE_URI="${ACR_LOGIN_SERVER}/${IMG_NAME}:${IMG_TAG}"

            echo "Building ${IMAGE_URI} from ${FRONTEND_DIR}"
            docker build -t "$IMAGE_URI" "$FRONTEND_DIR"
            docker push "$IMAGE_URI"

            # Save image metadata for deploy job
            META_DIR="$(Build.ArtifactStagingDirectory)/frontend-image"
            mkdir -p "$META_DIR"
            cat > "$META_DIR/image.json" <<EOF
              {
                "acr_login_server": "$ACR_LOGIN_SERVER",
                "image_name": "$IMG_NAME",
                "image_tag": "$IMG_TAG",
              "image_uri": "$IMAGE_URI"
            }
            EOF

      - publish: $(Build.ArtifactStagingDirectory)/frontend-image
        artifact: frontend-image

      # Package Python Azure Function (zip) from your repo (api-function/)
      - bash: |
          set -euo pipefail
          FUNC_SRC="$(Build.SourcesDirectory)/api-function"
          OUT_DIR="$(Build.ArtifactStagingDirectory)/function"
          mkdir -p "$OUT_DIR"

          # sanity checks for your existing function app
          test -f "$FUNC_SRC/host.json" || { echo "api-function/host.json missing"; exit 1; }
          # If you have multiple functions, ensure their folders contain function.json

          cd "$FUNC_SRC"
          zip -r "$OUT_DIR/function.zip" . -x ".*" -x "__pycache__/*" -x "venv/*" >/dev/null
          echo "Created $OUT_DIR/function.zip"
        displayName: 'Package Python Azure Function (zip)'

      - publish: $(Build.ArtifactStagingDirectory)/azure-function-python
        artifact: azure-function-python


  # ---- dev_apps ----
  - job: deploy_apps
    displayName: 'Deploy apps (dev)'
    dependsOn:
      - build_dev
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    pool: { name: 'ubuntuvm' }
    steps:
      - download: current
        artifact: frontend-image
      - download: current
        artifact: function
      - download: current
        artifact: tf-outputs-$(env)

      - task: AzureCLI@2
        displayName: 'Point Web App to ACR image (Linux) + Deploy Function Zip'
        inputs:
          azureSubscription: '$(serviceConnection)'
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            set -euo pipefail

            TF_OUT="$(Pipeline.Workspace)/tf-outputs-$(env)/tf-outputs.$(env).json"
            IMG_META="$(Pipeline.Workspace)/frontend-image/image.json"
            test -f "$TF_OUT"   || { echo "Missing TF outputs $TF_OUT"; exit 1; }
            test -f "$IMG_META" || { echo "Missing image metadata $IMG_META"; exit 1; }

            RG=$(python3 -c "import json;print(json.load(open('$TF_OUT'))['resource_group_name']['value'])")
            WEB=$(python3 -c "import json;print(json.load(open('$TF_OUT'))['react_web_name']['value'])")
            FN=$(python3 -c "import json;print(json.load(open('$TF_OUT'))['function_name']['value'])")
            ACR_LOGIN_SERVER=$(python3 -c "import json;print(json.load(open('$IMG_META'))['acr_login_server'])")
            IMAGE_URI=$(python3 -c "import json;print(json.load(open('$IMG_META'))['image_uri'])")

            echo "RG=$RG WEB=$WEB FN=$FN"
            echo "IMAGE_URI=$IMAGE_URI"

            # Ensure target Web App is Linux
            KIND=$(az webapp show -g "$RG" -n "$WEB" --query "kind" -o tsv)
            RESERVED=$(az webapp show -g "$RG" -n "$WEB" --query "reserved" -o tsv)
            if [[ "${RESERVED}" != "true" && "${KIND}" != *"linux"* ]]; then
              echo "ERROR: Web App '$WEB' is not Linux."; exit 1
            fi

            # Configure Web App to use ACR image (managed identity pull)
            az webapp config container set \
              -g "$RG" -n "$WEB" \
              --docker-custom-image-name "$IMAGE_URI" \
              --docker-registry-server-url "https://${ACR_LOGIN_SERVER}" || true

            az webapp config set -g "$RG" -n "$WEB" --acr-use-managed-identity
            az webapp config appsettings set -g "$RG" -n "$WEB" --settings \
              WEBSITES_ENABLE_APP_SERVICE_STORAGE=false \
              WEBSITES_PORT=80
            az webapp restart -g "$RG" -n "$WEB"

            # Deploy Function zip
            FUNCTION_ZIP="$(Pipeline.Workspace)/function/function.zip"
            test -f "$FUNCTION_ZIP" || { echo "Function zip not found at $FUNCTION_ZIP"; exit 1; }
            az functionapp config appsettings set -g "$RG" -n "$FN" --settings SCM_DO_BUILD_DURING_DEPLOYMENT=true
            az functionapp deployment source config-zip -g "$RG" -n "$FN" --src "$FUNCTION_ZIP"

            # Best-effort smoke check
            curl -fsS "https://${FN}.azurewebsites.net/api/products" || true


# =========================
# TEST STAGE
# =========================
- stage: test
  displayName: 'TEST'
  variables: { env: 'test' }
  dependsOn: dev
  jobs:
  - job: build_test
    displayName: 'Build & package (test)'
    pool: { name: 'ubuntuvm' }
    steps:
      - checkout: self
        clean: true
      - bash: |
          set -euo pipefail
          mkdir -p "$(Build.SourcesDirectory)/_pkg/frontend" "$(Build.SourcesDirectory)/_pkg/function"
          echo "<html><body>placeholder</body></html>" > "$(Build.SourcesDirectory)/_pkg/frontend/index.html"
          echo "{}" > "$(Build.SourcesDirectory)/_pkg/function/host.json"
        displayName: 'Create placeholder files'
      - task: ArchiveFiles@2
        displayName: 'Zip frontend for frontend React app'
        inputs:
          rootFolderOrFile: '$(Build.SourcesDirectory)/_pkg/frontend'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/frontend/frontend.zip'
          replaceExistingArchive: true
      - task: ArchiveFiles@2
        displayName: 'Zip function for azure function with Python3'
        inputs:
          rootFolderOrFile: '$(Build.SourcesDirectory)/_pkg/function'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/function/function.zip'
          replaceExistingArchive: true

      - publish: $(Build.ArtifactStagingDirectory)/frontend
        artifact: frontend
      
      - publish: $(Build.ArtifactStagingDirectory)/function
        artifact: function

  - job: test_infra
    displayName: 'Deploy infra (test)'
    dependsOn: build_test
    pool: { 
      name: 'ubuntuvm' 
    }
    steps:
      - checkout: self
        clean: true
      - task: AzureCLI@2
        displayName: 'Login + tools + plan/apply (test)'
        inputs:
          azureSubscription: '$(serviceConnection)'
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            set -euo pipefail
            az account show

            BIN_DIR="$(Agent.TempDirectory)/bin"; mkdir -p "$BIN_DIR"; export PATH="$BIN_DIR:$PATH"
            # (install go/tfsec/tflint as before) ...

            tflint --init
            tflint --recursive
            tfsec "$(Build.SourcesDirectory)/terraform" || true

            TF_DIR="$(Build.SourcesDirectory)/terraform"
            terraform -chdir="$TF_DIR" init -input=false

            # --- Workspace: create only if missing ---
            ensure_ws() {
              local dir="$1" ws="$2"
              if terraform -chdir="$dir" workspace list | sed 's/*//;s/ //g' | grep -Fxq "$ws"; then
                terraform -chdir="$dir" workspace select "$ws"
              else
                terraform -chdir="$dir" workspace new "$ws"
              fi
            }
            ensure_ws "$TF_DIR" "$(env)"

            SUB_ID=$(az account show --query id -o tsv)
            RG_NAME="$(RG_NAME_PREFIX)-$(env)-rg"
            if az group exists -n "$RG_NAME"; then
              if ! terraform -chdir="$TF_DIR" state show azurerm_resource_group.ascension_test_rg >/dev/null 2>&1; then
                terraform -chdir="$TF_DIR" import azurerm_resource_group.ascension_test_rg "/subscriptions/$SUB_ID/resourceGroups/$RG_NAME" || true
              fi
            fi

            SC_CLIENT_ID="331a5bcb-b95d-4529-a528-c858e28d9a89"
            PIPELINE_PRINCIPAL_OBJECT_ID=$(az ad sp show --id "$SC_CLIENT_ID" --query id -o tsv)

            terraform -chdir="$TF_DIR" plan -no-color -input=false \
              -var="workflow=$(env)" \
              -var="pipeline_principal_id=$PIPELINE_PRINCIPAL_OBJECT_ID" \
              -var="frontend_image_name=frontend-$(env)" \
              -var="frontend_image_tag=${BUILD_BUILDID}" \
              -out="tfplan.$(env).out"

            if [ "$(Build.SourceBranch)" = "refs/heads/main" ]; then
              terraform -chdir="$TF_DIR" apply -auto-approve -no-color "tfplan.$(env).out"
              terraform -chdir="$TF_DIR" output -json > "$TF_DIR/tf-outputs.$(env).json"
            else
              echo "Not main branch, skipping apply."
            fi

      - publish: $(Build.SourcesDirectory)/terraform/tf-outputs.$(env).json
        artifact: tf-outputs-$(env)
        condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))

  - job: test_apps
    displayName: 'Deploy apps (test)'
    dependsOn:
      - build_test
      - test_infra
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    pool: { name: 'ubuntuvm' }
    steps:
      - download: current
        artifact: frontend
        displayName: 'Get frontend artifact'
      - download: current
        artifact: function
        displayName: 'Get function artifact'
      - download: current
        artifact: tf-outputs-$(env)
        displayName: 'Get tf-outputs artifact'
      - task: AzureCLI@2
        displayName: 'Deploy frontend + function (test)'
        inputs:
          azureSubscription: '$(serviceConnection)'
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            set -euo pipefail
            FRONTEND_ZIP="$(Pipeline.Workspace)/frontend/frontend.zip"
            FUNCTION_ZIP="$(Pipeline.Workspace)/function/function.zip"
            TF_OUT="$(Pipeline.Workspace)/tf-outputs-$(env)/tf-outputs.$(env).json"
            RG=$(python3 -c "import json;print(json.load(open('$TF_OUT'))['resource_group_name']['value'])")
            WEB=$(python3 -c "import json;print(json.load(open('$TF_OUT'))['react_web_name']['value'])")
            FN=$(python3 -c "import json;print(json.load(open('$TF_OUT'))['function_name']['value'])")
            az webapp deployment source config-zip -g "$RG" -n "$WEB" --src "$FRONTEND_ZIP"
            az functionapp config appsettings set -g "$RG" -n "$FN" --settings SCM_DO_BUILD_DURING_DEPLOYMENT=true
            az functionapp deployment source config-zip -g "$RG" -n "$FN" --src "$FUNCTION_ZIP"
            curl -fsS "https://${FN}.azurewebsites.net/api/products" || true

# =========================
# PROD STAGE
# =========================
- stage: prod
  displayName: 'PROD'
  variables: { env: 'prod' }
  dependsOn: test
  jobs:
  - job: build_prod
    displayName: 'Build & package (prod)'
    pool: { name: 'ubuntuvm' }
    steps:
      - checkout: self
        clean: true
      - bash: |
          set -euo pipefail
          mkdir -p "$(Build.SourcesDirectory)/_pkg/frontend" "$(Build.SourcesDirectory)/_pkg/function"
          echo "<html><body>placeholder</body></html>" > "$(Build.SourcesDirectory)/_pkg/frontend/index.html"
          echo "{}" > "$(Build.SourcesDirectory)/_pkg/function/host.json"
        displayName: 'Create placeholder files'
      - task: ArchiveFiles@2
        displayName: 'Zip frontend'
        inputs:
          rootFolderOrFile: '$(Build.SourcesDirectory)/_pkg/frontend'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/frontend/frontend.zip'
          replaceExistingArchive: true
      - task: ArchiveFiles@2
        displayName: 'Zip function'
        inputs:
          rootFolderOrFile: '$(Build.SourcesDirectory)/_pkg/function'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/function/function.zip'
          replaceExistingArchive: true
      - publish: $(Build.ArtifactStagingDirectory)/frontend
        artifact: frontend
      - publish: $(Build.ArtifactStagingDirectory)/function
        artifact: function

  - job: prod_infra
    displayName: 'Deploy infra (prod)'
    dependsOn: build_prod
    pool: { name: 'ubuntuvm' }
    steps:
      - checkout: self
        clean: true
      - task: AzureCLI@2
        displayName: 'Login + tools + plan/apply (prod)'
        inputs:
          azureSubscription: '$(serviceConnection)'
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            set -euo pipefail
            az account show

            BIN_DIR="$(Agent.TempDirectory)/bin"; mkdir -p "$BIN_DIR"; export PATH="$BIN_DIR:$PATH"
            # (install go/tfsec/tflint as before) ...

            tflint --init
            tflint --recursive
            tfsec "$(Build.SourcesDirectory)/terraform" || true

            TF_DIR="$(Build.SourcesDirectory)/terraform"
            terraform -chdir="$TF_DIR" init -input=false

            # --- Workspace: create only if missing ---
            ensure_ws() {
              local dir="$1" ws="$2"
              if terraform -chdir="$dir" workspace list | sed 's/*//;s/ //g' | grep -Fxq "$ws"; then
                terraform -chdir="$dir" workspace select "$ws"
              else
                terraform -chdir="$dir" workspace new "$ws"
              fi
            }
            ensure_ws "$TF_DIR" "$(env)"

            SUB_ID=$(az account show --query id -o tsv)
            RG_NAME="$(RG_NAME_PREFIX)-$(env)-rg"
            if az group exists -n "$RG_NAME"; then
              if ! terraform -chdir="$TF_DIR" state show azurerm_resource_group.ascension_test_rg >/dev/null 2>&1; then
                terraform -chdir="$TF_DIR" import azurerm_resource_group.ascension_test_rg "/subscriptions/$SUB_ID/resourceGroups/$RG_NAME" || true
              fi
            fi

            SC_CLIENT_ID="331a5bcb-b95d-4529-a528-c858e28d9a89"
            PIPELINE_PRINCIPAL_OBJECT_ID=$(az ad sp show --id "$SC_CLIENT_ID" --query id -o tsv)

            terraform -chdir="$TF_DIR" plan -no-color -input=false \
              -var="workflow=$(env)" \
              -var="pipeline_principal_id=$PIPELINE_PRINCIPAL_OBJECT_ID" \
              -var="frontend_image_name=frontend-$(env)" \
              -var="frontend_image_tag=${BUILD_BUILDID}" \
              -out="tfplan.$(env).out"

            if [ "$(Build.SourceBranch)" = "refs/heads/main" ]; then
              terraform -chdir="$TF_DIR" apply -auto-approve -no-color "tfplan.$(env).out"
              terraform -chdir="$TF_DIR" output -json > "$TF_DIR/tf-outputs.$(env).json"
            else
              echo "Not main branch, skipping apply."
            fi

      - publish: $(Build.SourcesDirectory)/terraform/tf-outputs.$(env).json
        artifact: tf-outputs-$(env)
        condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))

  - job: prod_apps
    displayName: 'Deploy apps (prod)'
    dependsOn:
      - build_prod
      - prod_infra
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    pool: { name: 'ubuntuvm' }
    steps:
      - download: current
        artifact: frontend
        displayName: 'Get frontend artifact'
      - download: current
        artifact: function
        displayName: 'Get function artifact'
      - download: current
        artifact: tf-outputs-$(env)
        displayName: 'Get tf-outputs artifact'
      - task: AzureCLI@2
        displayName: 'Deploy frontend + function (prod)'
        inputs:
          azureSubscription: '$(serviceConnection)'
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            set -euo pipefail
            FRONTEND_ZIP="$(Pipeline.Workspace)/frontend/frontend.zip"
            FUNCTION_ZIP="$(Pipeline.Workspace)/function/function.zip"
            TF_OUT="$(Pipeline.Workspace)/tf-outputs-$(env)/tf-outputs.$(env).json"
            RG=$(python3 -c "import json;print(json.load(open('$TF_OUT'))['resource_group_name']['value'])")
            WEB=$(python3 -c "import json;print(json.load(open('$TF_OUT'))['react_web_name']['value'])")
            FN=$(python3 -c "import json;print(json.load(open('$TF_OUT'))['function_name']['value'])")
            az webapp deployment source config-zip -g "$RG" -n "$WEB" --src "$FRONTEND_ZIP"
            az functionapp config appsettings set -g "$RG" -n "$FN" --settings SCM_DO_BUILD_DURING_DEPLOYMENT=true
            az functionapp deployment source config-zip -g "$RG" -n "$FN" --src "$FUNCTION_ZIP"
            curl -fsS "https://${FN}.azurewebsites.net/api/products" || true

# ===== Optional destroy (linear after prod) =====
- stage: destroy
  displayName: 'Terraform destroy (guarded)'
  dependsOn: prod
  condition: and(succeeded(), eq(variables['doDestroy'], 'true'))
  jobs:
  - job: destroy_all
    pool: { name: 'ubuntuvm' }
    strategy:
      matrix:
        dev:  { env: dev }
        test: { env: test }
        prod: { env: prod }
    steps:
      - checkout: self
        clean: true
      - task: AzureCLI@2
        displayName: "Destroy $(env)"
        inputs:
          azureSubscription: '$(serviceConnection)'
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            set -euo pipefail
            terraform -chdir="$(Build.SourcesDirectory)/terraform" init -input=false
            terraform -chdir="$(Build.SourcesDirectory)/terraform" workspace select -or-create "$(env)"
            terraform -chdir="$(Build.SourcesDirectory)/terraform" destroy -no-color -auto-approve -var="workflow=$(env)"
